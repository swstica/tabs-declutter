# Implementation Guide - Tabs Declutter

Based on your current Gadget schema, here's a step-by-step implementation guide.

## Current State Analysis

✅ **What You Have:**
- `tabItem` model with basic fields (url, title, status, favicon)
- `declutterSession` model for workflow tracking
- User authentication
- ChatGPT connection configured
- Basic CRUD actions

❌ **What's Missing:**
- AI processing fields (summary, category, priority, tags, domain)
- OpenAI integration
- Effects for async AI processing
- Collection models (optional)

---

## Step 1: Enhance `tabItem` Schema

Update `/api/models/tabItem/schema.gadget.ts` to add AI fields:

```typescript
import type { GadgetModel } from "gadget-server";

export const schema: GadgetModel = {
  type: "gadget/model-schema/v2",
  storageKey: "63XaFN9j51qQ",
  comment:
    "Stores information about individual browser tabs, including their URL, title, and status.",
  fields: {
    // ... existing fields ...
    declutterSession: {
      type: "belongsTo",
      validations: { required: false }, // Make optional so tabs can exist independently
      parent: { model: "declutterSession" },
      storageKey: "aekXWKFFZxne",
    },
    favicon: {
      type: "url",
      storageKey: "2oZWqcczzt03",
      searchIndex: false,
    },
    position: {
      type: "number",
      decimals: 0,
      storageKey: "F6qVbEbjLadD",
      searchIndex: false,
    },
    processedAt: {
      type: "dateTime",
      includeTime: true,
      storageKey: "FHKjpan7WQ2u",
      searchIndex: false,
    },
    status: {
      type: "enum",
      acceptMultipleSelections: false,
      acceptUnlistedOptions: false,
      options: ["unread", "keep", "read", "delete"],
      validations: { required: true },
      storageKey: "pkrlgwjFOfzm",
    },
    title: {
      type: "string",
      validations: { required: true },
      storageKey: "ULImE5vrPQF1",
    },
    url: {
      type: "url",
      validations: { required: true },
      storageKey: "jEODPs6N45IA",
    },
    user: {
      type: "belongsTo",
      validations: { required: true },
      parent: { model: "user" },
      storageKey: "jaox9ibIjdcc",
    },
    
    // NEW: Add these AI processing fields
    domain: {
      type: "string",
      storageKey: "domain_xyz", // Gadget will generate actual key
      searchIndex: true, // Enable filtering by domain
    },
    summary: {
      type: "string",
      storageKey: "summary_xyz",
      searchIndex: true, // Enable search in summaries
    },
    category: {
      type: "enum",
      options: ["News", "Technology", "Entertainment", "Education", "Work", "Shopping", "Social", "Health", "Finance", "Travel", "Other"],
      acceptMultipleSelections: false,
      acceptUnlistedOptions: false,
      storageKey: "category_xyz",
      searchIndex: true,
    },
    priority: {
      type: "number",
      decimals: 0,
      validations: { min: 1, max: 5 },
      storageKey: "priority_xyz",
      searchIndex: true,
    },
    tags: {
      type: "richText", // Store as JSON string, or use separate Tag model
      storageKey: "tags_xyz",
      // Alternative: Create separate Tag model with many-to-many relationship
    },
  },
};
```

**Note:** After updating the schema, you'll need to sync it with Gadget. The storage keys will be auto-generated by Gadget when you add fields through the dashboard, or you can let Gadget handle it.

---

## Step 2: Install OpenAI Plugin

1. In Gadget dashboard, go to **Plugins**
2. Install **OpenAI** plugin
3. Add your OpenAI API key
4. This gives you access to `connections.openai` in your actions/effects

---

## Step 3: Enhance `create` Action to Extract Domain

Update `/api/models/tabItem/actions/create.ts`:

```typescript
import { applyParams, save, ActionOptions } from "gadget-server";
import { preventCrossUserDataAccess } from "gadget-server/auth";

export const run: ActionRun = async ({ params, record, logger, api, connections }) => {
  applyParams(params, record);
  await preventCrossUserDataAccess(params, record);
  
  // Extract domain from URL
  try {
    if (record.url) {
      const urlObj = new URL(record.url);
      record.domain = urlObj.hostname.replace(/^www\./, ''); // Remove www. prefix
    }
  } catch (error) {
    logger.warn("Failed to extract domain from URL", { url: record.url, error });
    // Continue without domain - not critical
  }
  
  // Set default status if not provided
  if (!record.status) {
    record.status = "unread";
  }
  
  await save(record);
  
  // Note: AI processing will happen in the effect (see Step 4)
};
```

---

## Step 4: Create Effect for AI Processing

Create `/api/models/tabItem/effects/afterCreate.ts`:

```typescript
import type { AfterCreateEffect } from "gadget-server";

export const run: AfterCreateEffect = async ({ record, logger, api, connections }) => {
  // Skip if OpenAI is not configured
  if (!connections.openai) {
    logger.warn("OpenAI connection not available, skipping AI processing");
    return;
  }

  try {
    logger.info("Starting AI processing for tab", { tabId: record.id, url: record.url });

    // Call OpenAI API
    const response = await connections.openai.chat.completions.create({
      model: "gpt-4o-mini", // Use gpt-4o-mini for cost efficiency, or gpt-4o for better quality
      messages: [
        {
          role: "system",
          content: `You are analyzing browser tabs to help a user manage their reading list. 
Analyze the tab and provide a JSON response with:
- summary: 1-2 sentence summary (max 150 characters)
- category: One of [News, Technology, Entertainment, Education, Work, Shopping, Social, Health, Finance, Travel, Other]
- priority: Number 1-5 (5=Critical, 4=High, 3=Medium, 2=Low, 1=Very Low)
- tags: Array of 3-5 relevant keywords/tags (lowercase, hyphenated for multi-word)

Consider:
- Time sensitivity (news, deadlines)
- Personal value (educational, work-related)
- Content quality indicators
- User's likely interests based on domain`
        },
        {
          role: "user",
          content: `Analyze this browser tab:
URL: ${record.url}
Title: ${record.title}
Domain: ${record.domain || 'unknown'}`
        }
      ],
      response_format: { type: "json_object" },
      temperature: 0.3, // Lower temperature for more consistent results
    });

    const analysis = JSON.parse(response.choices[0].message.content);

    // Validate and update tab with AI results
    const updates: any = {
      processedAt: new Date(),
    };

    if (analysis.summary && typeof analysis.summary === 'string') {
      updates.summary = analysis.summary.substring(0, 500); // Limit length
    }

    if (analysis.category && typeof analysis.category === 'string') {
      // Validate category is in allowed list
      const validCategories = ["News", "Technology", "Entertainment", "Education", "Work", "Shopping", "Social", "Health", "Finance", "Travel", "Other"];
      if (validCategories.includes(analysis.category)) {
        updates.category = analysis.category;
      }
    }

    if (analysis.priority && typeof analysis.priority === 'number') {
      // Clamp priority to 1-5
      updates.priority = Math.max(1, Math.min(5, Math.round(analysis.priority)));
    }

    if (analysis.tags && Array.isArray(analysis.tags)) {
      // Store tags as JSON string (or handle differently based on your schema)
      updates.tags = JSON.stringify(analysis.tags.slice(0, 5)); // Limit to 5 tags
    }

    // Update the tab with AI results
    await api.tabItem.update(record.id, updates);

    logger.info("AI processing completed", { tabId: record.id, updates });

  } catch (error: any) {
    logger.error("AI processing failed", { 
      tabId: record.id, 
      error: error.message,
      stack: error.stack 
    });
    
    // Don't throw - allow tab creation to succeed even if AI processing fails
    // The tab will just have null AI fields, which can be retried later
  }
};
```

---

## Step 5: Create Custom Actions for ChatGPT Interface

### Action: Query Tabs

Create `/api/actions/queryTabs.ts`:

```typescript
import type { ActionRun } from "gadget-server";

export const run: ActionRun = async ({ params, api, connections, logger }) => {
  const { query, filters } = params;
  const userId = connections.currentUser?.id;

  if (!userId) {
    throw new Error("User must be authenticated");
  }

  // Build filter object
  const filter: any = {
    user: { equals: userId },
  };

  // Apply filters
  if (filters?.status) {
    filter.status = { equals: filters.status };
  }
  if (filters?.category) {
    filter.category = { equals: filters.category };
  }
  if (filters?.minPriority) {
    filter.priority = { greaterThanOrEqual: filters.minPriority };
  }
  if (filters?.domain) {
    filter.domain = { equals: filters.domain };
  }

  // Search in title/summary if query provided
  if (query) {
    filter._or = [
      { title: { contains: query } },
      { summary: { contains: query } },
    ];
  }

  // Fetch tabs
  const tabs = await api.tabItem.findMany({
    filter,
    sort: filters?.sortBy === "priority" 
      ? { priority: "desc" }
      : { createdAt: "desc" },
    first: filters?.limit || 50,
  });

  return {
    tabs: tabs.map(tab => ({
      id: tab.id,
      url: tab.url,
      title: tab.title,
      domain: tab.domain,
      summary: tab.summary,
      category: tab.category,
      priority: tab.priority,
      status: tab.status,
      createdAt: tab.createdAt,
    })),
    count: tabs.length,
  };
};
```

### Action: Get Unread Tabs

Create `/api/actions/getUnreadTabs.ts`:

```typescript
import type { ActionRun } from "gadget-server";

export const run: ActionRun = async ({ params, api, connections }) => {
  const userId = connections.currentUser?.id;
  const { limit = 20, sortBy = "priority" } = params || {};

  const tabs = await api.tabItem.findMany({
    filter: {
      user: { equals: userId },
      status: { equals: "unread" },
    },
    sort: sortBy === "priority" 
      ? { priority: "desc" }
      : { createdAt: "desc" },
    first: limit,
  });

  return { tabs };
};
```

### Action: Batch Update Tabs

Create `/api/actions/batchUpdateTabs.ts`:

```typescript
import type { ActionRun } from "gadget-server";

export const run: ActionRun = async ({ params, api, connections }) => {
  const { tabIds, updates } = params;
  const userId = connections.currentUser?.id;

  if (!Array.isArray(tabIds) || tabIds.length === 0) {
    throw new Error("tabIds must be a non-empty array");
  }

  // Verify all tabs belong to user
  const tabs = await api.tabItem.findMany({
    filter: {
      id: { in: tabIds },
      user: { equals: userId },
    },
  });

  if (tabs.length !== tabIds.length) {
    throw new Error("Some tabs not found or don't belong to user");
  }

  // Update all tabs
  const updatePromises = tabIds.map(id => 
    api.tabItem.update(id, updates)
  );

  await Promise.all(updatePromises);

  return { updated: tabIds.length };
};
```

---

## Step 6: Optional - Create Collection Models

If you want collections functionality, create these models:

### Collection Model

Create `/api/models/collection/schema.gadget.ts`:

```typescript
import type { GadgetModel } from "gadget-server";

export const schema: GadgetModel = {
  type: "gadget/model-schema/v2",
  storageKey: "collection_xyz", // Gadget generates
  comment: "Represents a group of tabs organized by user or AI",
  fields: {
    name: {
      type: "string",
      validations: { required: true },
      storageKey: "name_xyz",
    },
    description: {
      type: "string",
      storageKey: "description_xyz",
    },
    type: {
      type: "enum",
      options: ["user_created", "ai_suggested", "auto_category"],
      default: "user_created",
      acceptMultipleSelections: false,
      acceptUnlistedOptions: false,
      storageKey: "type_xyz",
    },
    user: {
      type: "belongsTo",
      validations: { required: true },
      parent: { model: "user" },
      storageKey: "user_xyz",
    },
  },
};
```

### CollectionTab Model

Create `/api/models/collectionTab/schema.gadget.ts`:

```typescript
import type { GadgetModel } from "gadget-server";

export const schema: GadgetModel = {
  type: "gadget/model-schema/v2",
  storageKey: "collectionTab_xyz",
  comment: "Join table for many-to-many relationship between Collections and Tabs",
  fields: {
    collection: {
      type: "belongsTo",
      validations: { required: true },
      parent: { model: "collection" },
      storageKey: "collection_xyz",
    },
    tabItem: {
      type: "belongsTo",
      validations: { required: true },
      parent: { model: "tabItem" },
      storageKey: "tabItem_xyz",
    },
    order: {
      type: "number",
      decimals: 0,
      storageKey: "order_xyz",
    },
    addedAt: {
      type: "dateTime",
      includeTime: true,
      storageKey: "addedAt_xyz",
    },
  },
};
```

---

## Step 7: Testing

### Test Tab Creation

1. Go to Gadget API Explorer
2. Test `createTabItem` action:
```json
{
  "url": "https://www.example.com/article",
  "title": "Example Article Title",
  "status": "unread"
}
```

3. Check that:
   - Tab is created
   - Domain is extracted
   - AI processing effect runs (check logs)
   - Tab is updated with summary, category, priority

### Test Query Actions

Test `queryTabs`:
```json
{
  "query": "javascript",
  "filters": {
    "status": "unread",
    "minPriority": 3
  }
}
```

---

## Step 8: Browser Extension Integration

Your browser extension should call:

```javascript
// POST to your Gadget API
const response = await fetch('https://tabs-declutter-test.gadget.app/api/tabItems', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${apiKey}`, // Or use session auth
  },
  body: JSON.stringify({
    tabItem: {
      url: tab.url,
      title: tab.title,
      status: 'unread',
    }
  })
});
```

---

## Next Steps

1. ✅ Update `tabItem` schema with AI fields
2. ✅ Install OpenAI plugin
3. ✅ Enhance create action
4. ✅ Create AI processing effect
5. ✅ Create query actions
6. ⏳ Test end-to-end
7. ⏳ Build browser extension
8. ⏳ Connect ChatGPT interface

---

## Troubleshooting

### AI Processing Not Running
- Check OpenAI plugin is installed and API key is set
- Check effect is properly named (`afterCreate.ts`)
- Check logs in Gadget dashboard

### Domain Extraction Failing
- Ensure URL is valid before creating tab
- Add try-catch in create action

### ChatGPT Not Showing Tabs
- Ensure actions are exposed in ChatGPT connection settings
- Check authentication is working
- Verify action responses match expected format

---

Let me know if you'd like me to:
1. Update the actual schema files in your project
2. Create the effect files
3. Create the custom actions
4. Help with testing



